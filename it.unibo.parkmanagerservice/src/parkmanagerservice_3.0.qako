System carparking

/*
 * Tabelle SQLITE
 * Utente(ID [PK], NAME, SURNAME, MAIL [UNIQUE], STATE, TIME)
 * 	STATE = "Interested", "Parked", "Pickup"
 * ParkingSlot(SLOTNUM [PK], SLOTSTATE, TOKEN, UID [FK])
 * 	SLOTSTATE = "Free", "Reserved", "Occupied"
 * 
 */

/* Messages for entering car */
Request	enter 		: 	enter(NAME,SURNAME,MAIL)
Reply	slotnum 	: 	slotnum(SLOTNUM) //{"slotnum":"0", "err":"","indoor":"free"} //FREE, OCCUPIED
Request	carenter	:	carenter(SLOTNUM, MAIL)
Reply	token		:	token(TOKEN) //{"token":"XXXXX","err":""}

/* Messages for pickup car */
Request pickup		:	pickup(TOKEN,MAIL)
Reply	canPickup	:	canPickup(X)//{"msg":""}

/* Messages for counters */
Dispatch dtfreeReached : dtfreeReached(X)
Dispatch itoccReached : itoccReached(X)
Dispatch startDtfreeCounter : startDtfreeCounter(X)
Dispatch startItoccCounter : startItoccCounter(X)
Dispatch stopCount : stopCount(X)

/* Messages for device */
Dispatch fanon : fanon(X)
Dispatch fanoff : fanoff(X)
Event criticaltemp : criticaltemp(X)
Event weighton : weighton(X)
Event weightoff : weightoff(X)
Event sonaron : sonaron(X)
Event sonaroff : sonaroff(X)
Dispatch dopolling : dopolling(TIME)
Dispatch stoppolling : stoppolling(X)

/* Messages for notification */
Dispatch notifyuser : notifyuser(NOTIFICATION)

/* Messages to trolley */
Dispatch parkcar : parkcar(SLOTNUM)
Dispatch pickup : pickup(SLOTNUM)

/* Main context */
Context ctxcarparking ip[host="localhost" port=8010]

/* Context for devices */
Context ctxthermometer ip[host="192.168.1.100" port=8001]
Context ctxfan ip[host="192.168.1.100" port=8002]
Context ctxsonar ip[host="192.168.1.100" port=8003]
Context ctxweightsensor ip[host="192.168.1.100" port=8004]

/* Actors for devices */
ExternalQActor fanactor context ctxfan
ExternalQActor weightsensoractor context ctxweightsensor

 /*
QActor parkingservicegui context ctxcarparking {
	
	[# 	var RECEIVED_SLOTNUM = 0
		var MY_TOKEN = 0
		val state = it.unibo.parkingstate.MockState
	#]
	
	State s0 initial {
		println("$name | started")
	} Goto requestToEnter
	
	
	State requestToEnter {
		request parkingmanagerservice -m enter : enter(hello)
		println("$name | sended request to enter")
	} Transition t
		whenReply slotnum -> receivedSlotnum
	
	State receivedSlotnum {
		printCurrentMessage
		onMsg (slotnum : slotnum(SLOTNUM)) {
			[# RECEIVED_SLOTNUM = payloadArg(0).toInt() #]
			println("$name | received reply with SLOTNUM=$RECEIVED_SLOTNUM")
		}
	} Goto waitMoveToIndoor if [# RECEIVED_SLOTNUM > 0 #] else noAvailableSlot
	
	State waitMoveToIndoor {
		println("$name | client is waiting the idoor is free")
	} Transition t
		whenMsg canEnterCar -> moveTheCar
	
	State moveTheCar {
		
		//Simulate client is entering the car into the indoor
		delay 5000
		[# state.setIndoorState(`it.unibo.parkingstate`.DoorState.OCCUPIED) #]
		println("$name | client has moved the car in the INDOOR")
		
		request parkingmanagerservice -m carenter : carenter($RECEIVED_SLOTNUM)
		println("$name | client has press CARENTER")
	} Transition t
		whenReply token -> receivedToken
	
	State receivedToken {
		printCurrentMessage
		onMsg (token : token(TOKEN)) {
			[# MY_TOKEN = payloadArg(0).toInt() #]
			println("$name | received reply with TOKEN=$MY_TOKEN")
		}
	} Goto requestToPickUp
	
	State requestToPickUp {
		delay 5000
		request parkingmanagerservice -m pickup : pickup($MY_TOKEN)
		println("$name | client has required to pickup the car")
	} Transition t
		whenReply canPickup -> waitPickupConfirm
	
	State waitPickupConfirm {
		printCurrentMessage
		println("$name | client is going to pick up his car")
	} Goto pickup
	
	State pickup{
		
		//Simulate client have pick up his car from the outdoor-area
		delay 5000
		[# state.setOutdoorState(`it.unibo.parkingstate`.DoorState.FREE) #]
		
		println("$name | client has picked up his car")
	}
	
	State noAvailableSlot {
		println("$name | no slot available... i go elsewhere or retry later")
	}
} */

QActor parkingmanagerservice context ctxcarparking {
	
	[#  
		it.unibo.parkmanagerservice.persistence.ParkingRepositories.createBasics(6)
		val userRepo = it.unibo.parkmanagerservice.persistence.ParkingRepositories.getUserRepository()
		val slotRepo = it.unibo.parkmanagerservice.persistence.ParkingRepositories.getParkingSlotRepository()
		val STATE = it.unibo.parkmanagerservice.bean.LocalDoorState.get()
		val INDOOR_QUEUE = it.unibo.parkmanagerservice.persistence.DoorQueues.getIndoorQueue()
		val OUTDOOR_QUEUE = it.unibo.parkmanagerservice.persistence.DoorQueues.getOutdoorQueue()
		var USER : it.unibo.parkmanagerservice.bean.User
		var SLOT_RTV : java.util.Optional<it.unibo.parkmanagerservice.bean.ParkingSlot>
		var SLOT : it.unibo.parkmanagerservice.bean.ParkingSlot
		var SLOTNUM : Long = 0
		var NOTIFICATION : it.unibo.parkmanagerservice.notification.Notification?
		val CHANNEL = it.unibo.parkmanagerservice.notification.NotificationChannel.channel
		var JSON : String
	#]
	
	State s0 initial {
		println("$name | started")
	} Goto work
	
	State work {
		println("$name | waiting for request...")
		updateResource [# "work" #]
	} Transition t
		whenRequest enter -> handleEnter
		whenRequest carenter -> handleCarEnter
		whenRequest pickup -> handlePickup
		whenEvent weighton -> handleSomeoneInIndoor
		whenEvent weightoff -> handleIndoorReturnFree
	
	State handleEnter {
		printCurrentMessage
		[# SLOTNUM = 0 #]
		onMsg (enter : enter(NAME,SURNAME,MAIL)) {
			[#
				USER = `it.unibo.parkmanagerservice`.bean.User(name = payloadArg(0), 
						surname = payloadArg(1), mail = payloadArg(2),
						state = `it.unibo.parkmanagerservice`.bean.UserState.INTERESTED,
						time = java.sql.Timestamp(System.currentTimeMillis())
				)
				userRepo!!.create(USER)
				
				SLOT_RTV = slotRepo!!.getFirstFree()
				if(SLOT_RTV.isPresent()) {
					SLOT = SLOT_RTV.get()
					SLOT.slotstate = `it.unibo.parkmanagerservice`.bean.ParkingSlotState.RESERVED
					USER.slot = SLOT
					SLOT.user = USER
					SLOTNUM = SLOT!!.slotnum
					userRepo!!.update(USER!!)
					slotRepo!!.update(SLOT!!)
					
					if(STATE.indoor == `it.unibo.parkingstate`.DoorState.FREE) {
						STATE.indoor = `it.unibo.parkingstate`.DoorState.RESERVED
						USER.state = `it.unibo.parkmanagerservice`.bean.UserState.INDOOR_RESERVED
						userRepo.update(USER)
						STATE.userIndoor = USER
						JSON = "{\"slotnum\":\"$SLOTNUM\",\"indoor\":\"FREE\"}"
				#]
						forward weightsensoractor -m dopolling : dopolling(ON)
						forward itocccounter -m startItoccCounter : startItoccCounter(START)
						
						
				[#
					} else {
						USER.state = `it.unibo.parkmanagerservice`.bean.UserState.INTERESTED
						INDOOR_QUEUE.addUser(USER)
						JSON = "{\"slotnum\":\"$SLOTNUM\",\"indoor\":\"OCCUPIED\"}"
					}
				}
			#]
		}
		
		println("$name | replying enter request with [SLOTNUM = $SLOTNUM]")
		replyTo enter with slotnum : slotnum($JSON)
		
		updateResource[# "reply with ${JSON!!}" #]
		
	} Goto work
	
	State handleSomeoneInIndoor {
		[# 
			STATE.indoor = `it.unibo.parkingstate`.DoorState.OCCUPIED
		#]
		
	} Goto work
	
	State handleIndoorReturnFree {
		forward itocccounter -m stopCount : stopCount(STOP)
		[# 
			if(STATE.indoor == `it.unibo.parkingstate`.DoorState.OCCUPIED && STATE.userIndoor != null) {
				USER = STATE.userIndoor!!
				USER.state = `it.unibo.parkmanagerservice`.bean.UserState.PARKED
				userRepo.update(USER)
				NOTIFICATION = `it.unibo.parkmanagerservice`.notification.DefaultNotificationFactory.createForUser(
					USER,
					`it.unibo.parkmanagerservice`.notification.NotificationType.TOKEN,
					arrayOf(USER.token!!)
				)
				if(NOTIFICATION != null) CHANNEL.send(NOTIFICATION!!)
				STATE.userIndoor = null
			}
			
			STATE.indoor = `it.unibo.parkingstate`.DoorState.FREE
		#]
		forward weightsensoractor -m stoppolling : stoppolling(STOP)
	} Goto enterNext if [# (STATE.indoorQueue.size > 0) #] else work
	
	State enterNext {
		[# 
			if(STATE.indoor = `it.unibo.parkingstate`.DoorState.FREE && INDOOR_QUEUE.remaining() > 0) {
				USER = INDOOR_QUEUE.getNextUser()
				
				while(USER.state != `it.unibo.parkmanagerservice`.bean.UserState.INTERESTED && INDOOR_QUEUE.remaining() > 0) {
					USER = INDOOR_QUEUE.getNextUser()
				}
				
				if(USER.state == `it.unibo.parkmanagerservice`.bean.UserState.INTERESTED) {
					STATE.indoor = `it.unibo.parkingstate`.DoorState.RESERVED
					STATE.userIndoor = USER
					USER.state = `it.unibo.parkmanagerservice`.bean.UserState.INDOOR_RESERVED
					userRepo.update(USER)		
					NOTIFICATION = `it.unibo.parkmanagerservice`.notification.DefaultNotificationFactory.createForUser(
						STATE.userIndoor!!,
						`it.unibo.parkmanagerservice`.notification.NotificationType.SLOTNUM,
						arrayOf("${'$'}U${STATE.userIndoor!!.id}S${STATE.userIndoor!!.slot!!.slotnum}")
					)
					if(NOTIFICATION != null) CHANNEL.send(NOTIFICATION!!)
		#]
					forward notificationactor -m notifyuser : notifyuser(NOTIFY)
					forward weightsensoractor -m dopolling : dopolling(ON)
					forward itocccounter -m startItoccCounter : startItoccCounter(START)
					
		[# 		}
			}
		#]
	} Goto work
	
	State handleCarEnter {
		printCurrentMessage
		onMsg(carenter : carenter(SLOTNUM,MAIL)) {
			[# 	if(STATE.indoor == `it.unibo.parkingstate`.DoorState.OCCUPIED) {
					if(STATE.userIndoor!!.mail.equals(payloadArg(1))) {
						if(STATE.userIndoor!!.slot!!.slotnum.toString().equals(payloadArg(0)) {
							SLOTNUM = STATE.userIndoor!!.slot!!.slotnum
							STATE.userIndoor.token = ${'$'}U${STATE.userIndoor!!.id}S${STATE.userIndoor!!.slot!!.slotnum}
			#]
							forward itocccounter -m stopCount:stopCount(STOP)
							forward trolley -m parkcar : parkcar($SLOTNUM)
			[#
						} else
							JSON = "{\"err\":\"The inserted SLOTNUM is not valid. Please try again.\"}"
					} else
						JSON = "{\"err\":\"The inserted MAIL is not valid. Please try again.\"}"
				} else {
				state.getParkingSlotManager().occupySlot(TOKEN)	#]
			
			println("$name | generated TOKEN=$TOKEN")
			replyTo carenter with token:token($TOKEN)
			updateResource[# "reply with TOKEN=$TOKEN" #]
			
			//Simulate trolley has take the car
			println("$name | trolley will take the car")
			
			[# 	state.setIndoorState(`it.unibo.parkingstate`.DoorState.FREE) } 
				state.setWeightOnSensor(0.0)
			#]
		}
	} Goto work
	
	State handlePickup {
		printCurrentMessage
		onMsg(pickup : pickup(TOKEN)) {
			[# 	var TOKEN = payloadArg(0) 
				var slotnum_free = state.getParkingSlotManager().freeSlotByToken(TOKEN) 
				 if(slotnum_free == -1) {
			#]
									
					replyTo pickup with canPickup : canPickup(INVALIDTOK)
					updateResource[# "canPickup(INVALIDTOK)"#]
					//TODO: handle invalid token
					
			[# 	} else {
					if(state.getOutdoorState().equals(`it.unibo.parkingstate`.DoorState.FREE)) { 
					state.setOutdoorState(`it.unibo.parkingstate`.DoorState.OCCUPIED)
			#]
					println("$name | trolley will transport car in the outdoor")
					replyTo pickup with canPickup : canPickup(OK)
					println("$name | slot $slotnum_free is going to be free")
					forward dtfreecounter -m startDtfreeCounter : startDtfreeCounter(START)
					
					updateResource[# "canPickup(OK)" #]
				
			[# 		} else { #]
					println("$name | the outdoor is already engaged by another car... please wait")
					replyTo pickup with canPickup : canPickup(WAIT)
					updateResource[# "canPickup(WAIT)"#]
					//TODO: if outdoor area is already engaged?
				
			[# 		}
				}				
			#]
		}
	} Goto work
}


QActor itocccounter context ctxcarparking {
	
	[# 	
		val state : it.unibo.parkingstate.StateReader = it.unibo.parkingstate.MockState
		val ITOCC = 2000L
	#]
	
	State s0 initial {
		println("$name | started")
	} Goto work
	
	State work {
		println("$name | working...")
		updateResource [# "work"#]
	} Transition t
		whenMsg startItoccCounter -> count
		whenMsg stopCount -> work
	
	State count {
		println("$name | start ITOCC count...")
		updateResource [# "count"#]
	} Transition t
		whenTimeVar ITOCC -> reached
		whenMsg startItoccCounter -> count
		whenMsg stopCount -> work
		
	State reached {
		[# if(state.getWeightFromSensor() <= 0) {#]
			//forward parkingservicegui -m itoccReached : itoccReached(REACHED)
			//TODO: how to notify to the client
			updateResource [# "ITOCC"#]
			println("$name | ITOCC reached and indoor is free... Client should be notified")
		[# } #]
	} Goto work
}

QActor dtfreecounter context ctxcarparking {
	[# 	
		val state : it.unibo.parkingstate.StateReader = it.unibo.parkingstate.MockState
		val DTFREE = 2000L
	#]
	
	State s0 initial {
		println("$name | started")
	} Goto work
	
	State work {
		println("$name | working...")
		updateResource[# "work" #]
	} Transition t
		whenMsg startDtfreeCounter -> count
		whenMsg stopCount -> work
	
	State count {
		println("$name | start DTFREE count...")
		updateResource[# "count" #]
	} Transition t
		whenTimeVar DTFREE -> reached
		whenMsg startDtfreeCounter -> count
		whenMsg stopCount -> work
	
	State reached {
		[# if(state.getDistanceFromSonar() >= 0) {#]
			//forward parkingservicestatusgui -m dtfreeReached : dtfreeReached(REACHED)
			updateResource [# "DTFREE"#]
			println("$name | DTFREE reached and outdoor is occupied... Manager has been notified")
		[# } #]
	} Goto work
}

QActor parkingservicestatusgui context ctxcarparking {
	State s0 initial {
		println("$name | started")
	} Goto work
	
	State work {
		println("$name | working")
	} Transition t
		whenMsg dtfreeReached -> receivedDtfreeAlarm
	
	State receivedDtfreeAlarm {
		println("$name | the manager has been notified for DTFREE reached")
	} Goto work
}

QActor notificationactor context ctxcarparking {
	
	[# 
		val NOTIFIER = it.unibo.parkmanagerservice.notification.MailNotifier()
		val CHANNEL = it.unibo.parkmanagerservice.notification.NotificationChannel.channel		
	#]
	
	State s0 initial {
		println("$name | started")
	}
	
	State work {
		println("$name | working")
	} Transition t0
		whenMsg notifyuser -> handleNotificationToSend
	
	State handleNotificationToSend {
		[# 
			NOTIFIER.sendNotification(CHANNEL.receive())
		#]
	} Goto work if [# CHANNEL.isEmpty #] else handleNotificationToSend
}

QActor antifireactor context ctxcarparking {
	
	[# var type : String #]
	
	State s0 initial {
		println("$name | started")
	} Goto work
	
	State work {
		println("$name | working")
	} Transition t0
		whenEvent criticaltemp -> handleCriticalTemp
	
	State handleCriticalTemp {
		onMsg(criticaltemp:criticaltemp(X)) {
			[# 
				type = payloadArg(0) 
				if(type.equals("CRITICAL")) {
					//Must send and alert to the manager
			#]
					println("$name | thermometer signaled critical temperature")
					forward fanactor -m fanon : fanon(ON)
			[#
				} else if(type.equals("NORMAL")) {
			#]
					println("$name | thermothere signaled normal temperature")
					forward fanactor -m fanoff : fanoff(OFF)
			[#
					
				}
			#]
		}
	} Goto work
}

QActor trolley context ctxcarparking {
	State s0 initial {
		println("$name | started")
	} Goto work
	
	State work {
		println("$name | work")
	} Transition t0
		whenMsg parkcar -> handlePark
		whenMsg pickup -> handlePickup
		
	State handlePark {
		
	} Goto work
	
	State handlePickup {
		
	} Goto work
}